// #include <stdio.h>

// int main(){

//     int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9 ,10};

//     for(int i = 0; i < 10; i++){
//         printf("%d번째의 주소값은 : %p입니다. \n", i, &arr[i]);
//     }
//     return 0;
// }

//출력 
// 0번째의 주소값은 : 000000000061FDF0입니다. 
// 1번째의 주소값은 : 000000000061FDF4입니다.
// 2번째의 주소값은 : 000000000061FDF8입니다.
// 3번째의 주소값은 : 000000000061FDFC입니다.
// 4번째의 주소값은 : 000000000061FE00입니다. 
// 5번째의 주소값은 : 000000000061FE04입니다.
// 6번째의 주소값은 : 000000000061FE08입니다.
// 7번째의 주소값은 : 000000000061FE0C입니다.
// 8번째의 주소값은 : 000000000061FE10입니다.
// 9번째의 주소값은 : 000000000061FE14입니다.

// 위의 결과를 본다면 배열의 인덱스가 커질 때마다 자료형의 크기만큼
// 더해진 다는 것을 알 수 있다.

// 예를 들어
// ex 
// int* p;
// int a;

// int p = a;
// p+1 은 p의 주소값에 p + 4가 더해지고, p+3이라면 p+4*3이다.


#include <stdio.h>

int main(){

    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9 ,10};
    int* parr;
    int i;
    parr = &arr[0];

    for (int i = 0; i < 10; i++)
    {
       printf("arr[%d]의 주소 : %p \n", i, &arr[i]);
       printf("(parr + %d)의 값 : %p  \n", i, (parr + i));

    if(&arr[i] == (parr +i)){
        printf(" --> 일치 \n");
    }else{
        printf(" --> 불일치 \n");
    }
    }
    
   
    return 0;
}

//출력 

// arr[0]의 주소 : 000000000061FDE0 
// (parr + 0)의 값 : 000000000061FDE0
//  --> 일치
// arr[1]의 주소 : 000000000061FDE4
// (parr + 1)의 값 : 000000000061FDE4
//  --> 일치
// arr[2]의 주소 : 000000000061FDE8 
// (parr + 2)의 값 : 000000000061FDE8
//  --> 일치
//  ...

// parr+1 .. +2 ...+3가 될떄마다 다음 인덱스의 값을 의미하기 때문에 
// &arr[1]이나 parr+1의 결과값은 일치한다.

// 예를 들어 
// arr[1] 랑 *(parr+1)을 하게 된다면 요소의 값을 의미하기에 아래와 같은
// 출력이 나온다.
// ++배열에서 배열의 이름은 배열의 첫 번째 인덱스의 주소값을 나타낸다.

// arr[0]의 주소 : 1 
// (parr + 0)의 값 : 1  
//  --> 일치
// arr[1]의 주소 : 2
// (parr + 1)의 값 : 2
//  --> 일치
// arr[2]의 주소 : 3
// (parr + 2)의 값 : 3
//  --> 일치
// arr[3]의 주소 : 4
